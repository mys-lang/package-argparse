from ansicolors import BOLD
from ansicolors import CYAN
from ansicolors import RED
from ansicolors import RESET
from ansicolors import UNDERLINE
from ansicolors import YELLOW
from string import indent
from string import join_and
from string import join_or

def _style_option(text: string) -> string:
    return f"{YELLOW}{text}{RESET}"

def _style_positional(text: string) -> string:
    return f"{CYAN}{text}{RESET}"

def _style_subcommand(text: string) -> string:
    return f"{CYAN}{text}{RESET}"

def _style_error(text: string) -> string:
    return f"{RED}{BOLD}{text}{RESET}"

def _bold(text: string) -> string:
    return f"{BOLD}{text}{RESET}"

def _underline(text: string) -> string:
    return f"{UNDERLINE}{text}{RESET}"

def _pad(value: string, count: i64) -> string:
    for _ in range(count):
        value += ' '

    return value

class ArgparseError(Error):
    message: string

class _Option:
    name: string
    short: string
    takes_value: bool
    default: string
    multiple_occurrences: bool
    choices: [string]
    help: string

    def __init__(self,
                 name: string,
                 short: string,
                 takes_value: bool,
                 default: string,
                 multiple_occurrences: bool,
                 choices: [string],
                 help: string):
        if multiple_occurrences and default is not None:
            raise ArgparseError(
                "multiple occurrences options cannot have a default value")

        if choices is not None and default is not None:
            if default not in choices:
                raise ArgparseError(
                    f"default value {default} must be {join_or(choices)}")

        self.name = name
        self.short = short
        self.default = default
        self.takes_value = takes_value

        if default is not None:
            self.takes_value = True

        self.multiple_occurrences = multiple_occurrences
        self.choices = choices
        self.help = help

    def is_flag(self) -> bool:
        return self.is_single_flag() or self.is_multiple_flag()

    def is_single_flag(self) -> bool:
        return not self.takes_value and not self.multiple_occurrences

    def is_multiple_flag(self) -> bool:
        return not self.takes_value and self.multiple_occurrences

    def is_single_value(self) -> bool:
        return self.takes_value and not self.multiple_occurrences

    def is_multiple_value(self) -> bool:
        return self.takes_value and self.multiple_occurrences

class _Positional:
    name: string
    multiple_occurrences: bool
    choices: [string]
    help: string

    def is_single_value(self) -> bool:
        return not self.multiple_occurrences

class _Reader:
    _argv: [string]
    _pos: u64

    def __init__(self, argv: [string], pos: u64):
        self._argv = argv
        self._pos = pos

    def available(self) -> bool:
        return self._pos < len(self._argv)

    def get(self) -> string:
        arg = self._argv[self._pos]
        self._pos += 1

        return arg

    def unget(self):
        self._pos -= 1

class Args:
    """Returned by the parser's parse method.

    """

    _options: {string: i64}
    _single_values: {string: string}
    _multiple_values: {string: [string]}
    _subcommand: (string, Args)
    remaining: [string]

    def __init__(self,
                 options: {string: i64},
                 single_values: {string: string},
                 multiple_values: {string: [string]},
                 subcommand: (string, Args)):
        self._options = options
        self._single_values = single_values
        self._multiple_values = multiple_values
        self._subcommand = subcommand
        self.remaining = []

    def is_present(self, arg: string) -> bool:
        """Returns true if given presence (boolean) option was given, false
        otherwise.

        """

        return self.occurrences_of(arg) > 0

    def occurrences_of(self, arg: string) -> u64:
        """Returns the number of times given presence (boolean) option was
        given.

        """

        count = self._options.get(arg, -1)

        if count == -1:
            raise ArgparseError(f"{arg} does not exist")

        return u64(count)

    def value_of(self, arg: string) -> string:
        """Returns the value of given option or positional. Raises an error
        if given option does not take a value or if given positional can be
        given multiple times.

        """

        return self._single_values[arg]

    def values_of(self, arg: string) -> [string]:
        """Returns a list of values of given multiple occurrences option or
        positional.

        """

        return self._multiple_values[arg]

    def subcommand(self) -> (string, Args):
        """Returns a tuple of the subcommand and its arguments.

        """

        return self._subcommand

class Parser:
    """An argument parser.

    """

    name: string
    help: string
    version: string
    _parent: Parser  # ToDo: weak[Parser]
    _options: [_Option]
    _positionals: [_Positional]
    _subcommands: [Parser]
    _options_count: {string: i64}
    _single_values: {string: string}
    _multiple_values: {string: [string]}
    _subcommand: (string, Args)
    _positional_index: u64

    def __init__(self,
                 name: string = None,
                 help: string = None,
                 version: string = None,
                 parent: Parser = None):
        self.name = name
        self.help = help
        self.version = version
        self._parent = parent
        self._options = []
        self._positionals = []
        self._subcommands = []
        self._add_builtin_options()

    def add_option(self,
                   name: string,
                   short: string = None,
                   takes_value: bool = False,
                   default: string = None,
                   multiple_occurrences: bool = False,
                   choices: [string] = None,
                   help: string = None):
        """Add an option. Options must be added before subcommands and
        positionals.

        """

        if self._subcommands != [] or self._positionals != []:
            raise ArgparseError(
                "options must be added before subcommands and positionals")

        if not name.starts_with("--"):
            raise ArgparseError("long options must start with '--'")

        if short is not None:
            if len(short) != 2 or short[0] != '-' or short[1] == '-':
                raise ArgparseError(
                    "short options must be a '-' followed by any character "
                    "except '-'")

        self._options.append(_Option(name,
                                     short,
                                     takes_value,
                                     default,
                                     multiple_occurrences,
                                     choices,
                                     help))

    def add_positional(self,
                       name: string,
                       multiple_occurrences: bool = False,
                       choices: [string] = None,
                       help: string = None):
        """Add a positional. Positionals cannot be mixed with subcommands.

        """

        if name.starts_with("-"):
            raise ArgparseError("positionals must not start with '-'")

        if self._subcommands != []:
            raise ArgparseError("positionals and subcommands cannot be mixed")

        if self._positionals != []:
            if self._positionals[-1].multiple_occurrences:
                raise ArgparseError(
                    "only the last posistional can occur multiple times")

        self._positionals.append(_Positional(name,
                                             multiple_occurrences,
                                             choices,
                                             help))

    def add_subcommand(self,
                       name: string,
                       help: string = None) -> Parser:
        """Add a subcommand. Subcommands cannot be mixed with positionals.

        """

        if name.starts_with("-"):
            raise ArgparseError("subcommands must not start with '-'")

        if self._positionals != []:
            raise ArgparseError("positionals and subcommands cannot be mixed")

        parser = Parser(name, help=help, parent=self)
        self._subcommands.append(parser)

        return parser

    def parse(self,
              argv: [string],
              exit_on_error: bool = True,
              allow_remaining: bool = False) -> Args:
        """Parse given arguments and return them.

        Give exit_on_error as False to raise an exception instead of
        exiting if an error occurs.

        Give allow_remaining to allow more non-option arguments than
        the parser expects. Remaining arguments are part of the
        returned value.

        """

        if self.name is None and len(argv) > 0:
            self.name = argv[0]

        reader = _Reader(argv, pos=1)

        try:
            args = self.parse_inner(reader)

            if reader.available():
                remaining: [string] = []

                while reader.available():
                    remaining.append(reader.get())

                if allow_remaining:
                    args.remaining = remaining
                else:
                    arguments = " ".join(remaining)

                    raise ArgparseError(
                        f"too many arguments, remaining: '{arguments}'")

            return args
        except ArgparseError as error:
            if exit_on_error:
                prefix = _style_error("error")

                raise SystemExitError(f"{prefix}: {error.message}")
            else:
                raise

    def print_help(self):
        prefix = self.format_synopsis_prefix()
        suffixes: [string] = []

        if self._options != []:
            suffixes.append(_style_option("[options]"))

        if self._subcommands != []:
            suffixes.append(_style_subcommand("<subcommand>"))

        for positional in self._positionals:
            suffixes.append(_style_positional(f"<{positional.name}>"))

        suffix = " ".join(suffixes)

        if suffix != "":
            suffix = " " + suffix

        name = _bold(prefix + self.name)
        synopsis = _underline("Synopsis")

        print(synopsis)
        print(f"  {name}{suffix}")

        if self.help is not None:
            print()
            print(_underline("Description"))
            print(indent(self.help, "  "))

        self._print_subcommands_help()
        self._print_positionals_help()
        self._print_options_help()

    def format_synopsis_prefix(self) -> string:
        if self._parent is not None:
            prefix = self._parent.format_synopsis_prefix()

            return f"{prefix}{self._parent.name} "
        else:
            return ""

    def _print_subcommands_help(self):
        if self._subcommands == []:
            return

        print()
        print(_underline("Subcommands"))
        entries: [(string, i64, string)] = []
        longest_name: i64 = 0

        for subcommand in self._subcommands:
            help = ""

            if subcommand.help is not None:
                help = subcommand.help

            name = subcommand.name
            name_length = i64(len(name))
            longest_name = max(name_length, longest_name)
            entries.append((name, name_length, help))

        for name, name_length, help in entries:
            name = _pad(name, longest_name - name_length)
            print(f"  {_style_subcommand(name)}    {help}")

    def _print_options_help(self):
        if self._options == []:
            return

        print()
        print(_underline("Options"))
        entries: [(string, i64, string)] = []
        longest_options: i64 = 0

        for option in self._options:
            help = ""

            if option.help is not None:
                help = option.help

            if option.short is not None:
                short = f"{option.short}, "
            else:
                short = ""

            options = short + option.name
            options_length = i64(len(options))
            longest_options = max(options_length, longest_options)
            entries.append((options, options_length, help))

        for options, options_length, help in entries:
            options = _pad(options, longest_options - options_length)
            print(f"  {_style_option(options)}    {help}")

    def _print_positionals_help(self):
        if self._positionals == []:
            return

        print()
        print(_underline("Positionals"))
        entries: [(string, i64, string)] = []
        longest_name: i64 = 0

        for positional in self._positionals:
            help = ""

            if positional.help is not None:
                help = positional.help

            name = positional.name
            name_length = i64(len(name))
            longest_name = max(name_length, longest_name)
            entries.append((name, name_length, help))

        for name, name_length, help in entries:
            name = _pad(name, longest_name - name_length)
            print(f"  {_style_positional(name)}    {help}")

    def _find_option(self, name: string) -> _Option:
        for option in self._options:
            if option.name == name or option.short == name:
                return option

        raise ArgparseError(f"invalid option {_style_error(name)}")

    def _short_to_long_option(self, short: string) -> string:
        for option in self._options:
            if option.short == short:
                return option.name

        raise ArgparseError(f"invalid option {_style_error(short)}")

    def _expand_option(self, option: string) -> [string]:
        options: [string] = []

        if option.starts_with("--"):
            options.append(option)
        else:
            for short in slice(option, 1):
                options.append(self._short_to_long_option(f"-{short}"))

        return options

    def _add_builtin_options(self):
        self.add_option("--help",
                        short="-h",
                        help="Show this help.")

        if self.version is not None:
            self.add_option("--version",
                            help="Show version infomation.")

    def _handle_builtin_options(self, name: string):
        if name == "--help":
            self.print_help()

            raise SystemExitError()

        if self.version is not None:
            if name == "--version":
                print(self.version)

                raise SystemExitError()

    def _parse_option(self, reader: _Reader):
        option_name = reader.get()

        for name in self._expand_option(option_name):
            option = self._find_option(name)

            self._handle_builtin_options(name)

            if option.is_single_flag():
                if self._options_count[name] > 0:
                    raise ArgparseError(
                        f"{_style_option(name)} can only be given once")

                self._options_count[name] = 1
            elif option.is_multiple_flag():
                self._options_count[name] += 1
            else:
                if not reader.available():
                    raise ArgparseError(
                        f"value missing for option {_style_option(name)}")

                value = reader.get()

                if option.choices is not None:
                    if value not in option.choices:
                        choices = [_style_option(choice)
                                   for choice in option.choices]

                        raise ArgparseError(
                            f"invalid value {_style_error(value)} to option "
                            f"{_style_option(name)}, choose from "
                            f"{join_and(choices)}")

                if option.is_single_value():
                    if self._single_values[name] is not None:
                        raise ArgparseError(
                            f"{_style_option(name)} can only be given once")

                    self._single_values[name] = value
                else:
                    self._multiple_values[name].append(value)

    def _find_subcommand(self, name: string) -> Parser:
        for subcommand in self._subcommands:
            if subcommand.name == name:
                return subcommand

        choices = join_and([_style_subcommand(subcommand.name)
                            for subcommand in self._subcommands])

        raise ArgparseError(
            f"invalid subcommand {_style_error(name)}, choose from {choices}")

    def _parse_subcommand(self, reader: _Reader) -> (string, Args):
        subcommand = self._find_subcommand(reader.get())

        return (subcommand.name, subcommand.parse_inner(reader))

    def _parse_positional(self, reader: _Reader) -> bool:
        if self._positional_index == len(self._positionals):
            return False

        positional = self._positionals[self._positional_index]
        self._positional_index += 1
        name = positional.name
        value = reader.get()

        if positional.choices is not None:
            if value not in positional.choices:
                choices = [_style_positional(choice)
                           for choice in positional.choices]

                raise ArgparseError(
                    f"invalid value {_style_error(value)} to positional "
                    f"{_style_positional(name)}, choose from "
                    f"{join_and(choices)}")

        if positional.is_single_value():
            self._single_values[name] = value
        else:
            self._multiple_values[name] = [value]

            while reader.available():
                self._multiple_values[name].append(reader.get())

        return True

    def parse_inner(self, reader: _Reader) -> Args:
        self._options_count = {}
        self._single_values = {}
        self._multiple_values = {}
        self._subcommand = None
        self._positional_index = 0
        end_of_options_found = False

        for option in self._options:
            if option.is_flag():
                self._options_count[option.name] = 0
            elif option.is_single_value():
                self._single_values[option.name] = None
            elif option.is_multiple_value():
                self._multiple_values[option.name] = []

        while reader.available():
            argument = reader.get()

            if argument == "--" and not end_of_options_found:
                end_of_options_found = True
            else:
                reader.unget()

                if (end_of_options_found
                    or argument == "-"
                    or not argument.starts_with("-")):
                    if self._subcommands != []:
                        self._subcommand = self._parse_subcommand(reader)
                        break
                    elif not self._parse_positional(reader):
                        break
                else:
                    self._parse_option(reader)

        for option in self._options:
            if option.is_single_value():
                if self._single_values[option.name] is None:
                    self._single_values[option.name] = option.default

        if self._subcommands != []:
            if self._subcommand is None:
                choices = join_and([_style_subcommand(subcommand.name)
                                    for subcommand in self._subcommands])

                raise ArgparseError(f"subcommand missing, choose from {choices}")
        elif self._positional_index < len(self._positionals):
            positional = self._positionals[self._positional_index]

            raise ArgparseError(
                f"positional {_style_positional(positional.name)} missing")

        return Args(self._options_count,
                    self._single_values,
                    self._multiple_values,
                    self._subcommand)

@test
def test_cat_and_monkey_subcommands():
    parser = Parser("foo",
                    help="Does awesome things",
                    version="1.0.0")
    parser.add_option("--verbose",
                      short="-v",
                      multiple_occurrences=True,
                      help="Verbose output.")

    monkey = parser.add_subcommand("monkey", help="Some more stuff.")
    monkey.add_option("--height", default="80")
    monkey.add_positional("banana", multiple_occurrences=True, help="Banana?")

    cat = parser.add_subcommand("cat", help="What?")
    cat.add_option("--auto", short="-a")
    cat.add_option("--rate", default="10000")
    cat.add_positional("food")

    try:
        parser.parse(["foo"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"subcommand missing, choose from {CYAN}monkey{RESET} "
            f"and {CYAN}cat{RESET}")

    args = parser.parse(["foo", "--verbose", "cat", ""])
    assert args.occurrences_of("--verbose") == 1

    args = parser.parse(["foo", "-vvv", "cat", "rat"])
    assert args.occurrences_of("--verbose") == 3

    args = parser.parse(["foo", "cat", "--auto", "rat"])
    assert not args.is_present("--verbose")
    name, args = args.subcommand()
    assert name == "cat"
    assert args.is_present("--auto")
    assert args.value_of("--rate") == "10000"
    assert args.value_of("food") == "rat"

    args = parser.parse(["foo", "monkey", "--height", "75", "b1", "b2"])
    assert not args.is_present("--verbose")
    name, args = args.subcommand()
    assert name == "monkey"
    assert args.value_of("--height") == "75"
    assert args.values_of("banana") == ["b1", "b2"]

@test
def test_add_option_after_positional():
    parser = Parser("bar")
    parser.add_positional("out")

    try:
        parser.add_option("--verbose")
        assert False
    except ArgparseError as error:
        assert error.message == (
            "options must be added before subcommands and positionals")

@test
def test_add_multiple_occurrences_positional_before_positional():
    parser = Parser("bar")
    parser.add_positional("out", multiple_occurrences=True)

    try:
        parser.add_option("in")
        assert False
    except ArgparseError as error:
        assert error.message == (
            "options must be added before subcommands and positionals")

@test
def test_help():
    parser = Parser("foo",
                    help="Does awesome things",
                    version="1.0.0")
    parser.add_option("--verbose",
                      short="-v",
                      multiple_occurrences=True,
                      help="Verbose output.")

    monkey = parser.add_subcommand("monkey", help="Some more stuff.")
    monkey.add_option("--height", default="80")
    monkey.add_positional("banana", multiple_occurrences=True, help="Banana?")

    cat = parser.add_subcommand("cat", help="What?")
    cat.add_option("--auto", short="-a")
    cat.add_option("--rate", default="10000")
    cat.add_positional("food")

    try:
        parser.parse(["foo", "--help"])
        assert False
    except SystemExitError:
        pass

@test
def test_version():
    parser = Parser("foo", version="0.3.0")

    try:
        parser.parse(["foo", "--version"])
        assert False
    except SystemExitError:
        pass

@test
def test_no_version():
    parser = Parser("foo")

    try:
        parser.parse(["foo", "--version"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"invalid option {RED}{BOLD}--version{RESET}"

@test
def test_is_present():
    parser = Parser("bar")
    parser.add_option("--foo")

    args = parser.parse(["bar", "--foo"])
    assert args.is_present("--foo")

    args = parser.parse(["bar"])
    assert not args.is_present("--foo")

@test
def test_is_present_bad_option():
    parser = Parser("bar")

    args = parser.parse(["bar"])

    try:
        args.is_present("--foo")
        assert False
    except ArgparseError as error:
        assert error.message == "--foo does not exist"

@test
def test_add_subcommand_after_positional():
    parser = Parser("bar")
    parser.add_positional("foo")

    try:
        parser.add_subcommand("cat")
        assert False
    except ArgparseError as error:
        assert error.message == "positionals and subcommands cannot be mixed"

@test
def test_add_positional_after_subcommand():
    parser = Parser("bar")
    parser.add_subcommand("cat")

    try:
        parser.add_positional("foo")
        assert False
    except ArgparseError as error:
        assert error.message == "positionals and subcommands cannot be mixed"

@test
def test_add_invalid_option():
    parser = Parser("bar")

    try:
        parser.add_option("cat")
        assert False
    except ArgparseError as error:
        assert error.message == "long options must start with '--'"

@test
def test_add_invalid_short_option_1():
    parser = Parser("bar")

    try:
        parser.add_option("--cat", short="d")
        assert False
    except ArgparseError as error:
        assert error.message == (
            "short options must be a '-' followed by any character except '-'")

@test
def test_add_invalid_short_option_2():
    parser = Parser("bar")

    try:
        parser.add_option("--cat", short="--g")
        assert False
    except ArgparseError as error:
        assert error.message == (
            "short options must be a '-' followed by any character except '-'")

@test
def test_add_invalid_short_option_3():
    parser = Parser("bar")

    try:
        parser.add_option("--cat", short="--")
        assert False
    except ArgparseError as error:
        assert error.message == (
            "short options must be a '-' followed by any character except '-'")

@test
def test_invalid_suncommand():
    parser = Parser("bar")
    parser.add_subcommand("cat")

    try:
        parser.parse(["bar", "foo"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"invalid subcommand {RED}{BOLD}foo{RESET}, choose "
            f"from {CYAN}cat{RESET}")

@test
def test_single_option_given_multiple_times():
    parser = Parser("bar")
    parser.add_option("--cat")

    try:
        parser.parse(["bar", "--cat", "--cat"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"{YELLOW}--cat{RESET} can only be given once"

@test
def test_all_arguments_not_used():
    parser = Parser("bar")
    parser.add_positional("cat")

    try:
        parser.parse(["bar", "apa", "ko"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == "too many arguments, remaining: 'ko'"

@test
def test_allow_remaining():
    parser = Parser("bar")

    args = parser.parse(["bar", "apa"], allow_remaining=True)

    assert args.remaining == ["apa"]

@test
def test_allow_remaining_option_after_dash_dash():
    parser = Parser("bar")
    parser.add_option("--cat")

    args = parser.parse(["bar", "--", "--cat", "apa"], allow_remaining=True)

    assert not args.is_present("--cat")
    assert args.remaining == ["--cat", "apa"]

@test
def test_allow_remaining_with_subparser():
    parser = Parser("bar")
    cat = parser.add_subcommand("cat")
    cat.add_option("--foo")

    args = parser.parse(["bar", "cat", "--", "apa", "--foo"], allow_remaining=True)

    assert args.remaining == ["apa", "--foo"]

    name, args = args.subcommand()
    assert name == "cat"
    assert args.remaining == []

@test
def test_multiple_occurrences_option_that_takes_value():
    parser = Parser("bar")
    parser.add_option("--cat",
                      takes_value=True,
                      multiple_occurrences=True)
    args = parser.parse(["bar", "--cat", "1", "--cat", "2"])
    assert args.values_of("--cat") == ["1", "2"]

@test
def test_multiple_occurrences_option_that_takes_value_missing_value():
    parser = Parser("bar")
    parser.add_option("--cat",
                      takes_value=True,
                      multiple_occurrences=True)

    try:
        parser.parse(["bar", "--cat", "1", "--cat"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"value missing for option {YELLOW}--cat{RESET}"

@test
def test_option_missing_value():
    parser = Parser()
    parser.add_option("--aaa", short="-a", takes_value=True)
    parser.add_option("--bbb", short="-b")

    try:
        parser.parse(["a", "-ab"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"value missing for option {YELLOW}--aaa{RESET}"

@test
def test_single_occurrence_option_that_takes_value_given_twice():
    parser = Parser("bar")
    parser.add_option("--cat", takes_value=True)

    try:
        parser.parse(["bar", "--cat", "1", "--cat", "2"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"{YELLOW}--cat{RESET} can only be given once"

@test
def test_missing_positional():
    parser = Parser("bar")
    parser.add_positional("cat")

    try:
        parser.parse(["bar"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"positional {CYAN}cat{RESET} missing"

@test
def test_no_name():
    parser = Parser()
    parser.parse(["bar"])
    assert parser.name == "bar"

@test
def test_exit_on_error():
    parser = Parser()

    try:
        parser.parse(["foo", "--version"])
        assert False
    except SystemExitError as error:
        assert str(error) == (
            "SystemExitError(message="
            f"\"{RED}{BOLD}error{RESET}: invalid option "
            f"{RED}{BOLD}--version{RESET}\")")

@test
def test_bad_option_single_dash():
    parser = Parser()

    try:
        parser.parse(["foo", "-"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == "too many arguments, remaining: '-'"

@test
def test_option_choices():
    parser = Parser("bar")
    parser.add_option("--cat",
                      takes_value=True,
                      choices=["a", "b"])

    args = parser.parse(["bar", "--cat", "a"])
    assert args.value_of("--cat") == "a"

    args = parser.parse(["bar", "--cat", "b"])
    assert args.value_of("--cat") == "b"

    try:
        parser.parse(["bar", "--cat", "c"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"invalid value {RED}{BOLD}c{RESET} to option "
            f"{YELLOW}--cat{RESET}, choose from {YELLOW}a{RESET} and "
            f"{YELLOW}b{RESET}")

@test
def test_positional_choices():
    parser = Parser("bar")
    parser.add_positional("cat", choices=["a", "b"])

    args = parser.parse(["bar", "a"])
    assert args.value_of("cat") == "a"

    args = parser.parse(["bar", "b"])
    assert args.value_of("cat") == "b"

    try:
        parser.parse(["bar", "c"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"invalid value {RED}{BOLD}c{RESET} to positional "
            f"{CYAN}cat{RESET}, choose from {CYAN}a{RESET} and "
            f"{CYAN}b{RESET}")

@test
def test_end_of_options():
    parser = Parser()
    parser.add_option("--cat")
    foo = parser.add_subcommand("foo")
    foo.add_option("--cat")
    foo.add_positional("in")
    foo.add_positional("out")

    try:
        parser.parse(["bar", "--", "--cat"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"invalid subcommand {RED}{BOLD}--cat{RESET}, choose "
            f"from {CYAN}foo{RESET}")

    args = parser.parse(["bar", "--", "foo", "-", "-"])
    _, args = args.subcommand()
    assert args.value_of("in") == "-"
    assert args.value_of("out") == "-"

    args = parser.parse(["bar", "--", "foo", "--", "-", "-"])
    _, args = args.subcommand()
    assert args.value_of("out") == "-"

    args = parser.parse(["bar", "foo", "a", "--", "--cat"])
    _, args = args.subcommand()
    assert args.value_of("in") == "a"
    assert args.value_of("out") == "--cat"
    assert not args.is_present("--cat")

    try:
        parser.parse(["bar", "foo", "a", "--cat"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"positional {CYAN}out{RESET} missing"

    args = parser.parse(["bar", "foo", "a", "--cat", "b"])
    _, args = args.subcommand()
    assert args.value_of("in") == "a"
    assert args.value_of("out") == "b"
    assert args.is_present("--cat")

    try:
        parser.parse(["bar", "foo", "a", "--", "--cat", "b", "c", "d"],
                     exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == "too many arguments, remaining: 'b c d'"

    args = parser.parse(["bar", "foo", "a", "--", "--"])
    _, args = args.subcommand()
    assert args.value_of("in") == "a"
    assert args.value_of("out") == "--"
    assert not args.is_present("--cat")

@test
def test_positional_name_must_not_start_with_dash():
    parser = Parser()

    try:
        parser.add_positional("--out")
        assert False
    except ArgparseError as error:
        assert error.message == "positionals must not start with '-'"

@test
def test_subcommand_name_must_not_start_with_dash():
    parser = Parser()

    try:
        parser.add_subcommand("--out")
        assert False
    except ArgparseError as error:
        assert error.message == "subcommands must not start with '-'"
