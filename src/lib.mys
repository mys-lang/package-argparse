from ansicolors import BOLD
from ansicolors import CYAN
from ansicolors import RED
from ansicolors import RESET
from ansicolors import UNDERLINE
from ansicolors import YELLOW
from string import indent
from string import join_and
from string import join_or

def _style_option(text: string) -> string:
    return f"{YELLOW}{text}{RESET}"

def _style_positional(text: string) -> string:
    return f"{CYAN}{text}{RESET}"

def _style_subcommand(text: string) -> string:
    return f"{CYAN}{text}{RESET}"

def _style_error(text: string) -> string:
    return f"{RED}{BOLD}{text}{RESET}"

def _bold(text: string) -> string:
    return f"{BOLD}{text}{RESET}"

def _underline(text: string) -> string:
    return f"{UNDERLINE}{text}{RESET}"

def _pad(value: string, count: i64) -> string:
    for _ in range(count):
        value += ' '

    return value

def _zsh_value_type_string(value_type: ValueType) -> string:
    match value_type:
        case ValueType.Path:
            return "_files"
        case ValueType.Hostname:
            return "_hosts"
        case _:
            return "( )"

class ArgparseError(Error):
    message: string

class _Option:
    name: string
    short: string
    takes_value: bool
    value_type: ValueType
    default: string
    multiple_occurrences: bool
    choices: [string]
    help: string

    def __init__(self,
                 name: string,
                 short: string,
                 takes_value: bool,
                 value_type: ValueType,
                 default: string,
                 multiple_occurrences: bool,
                 choices: [string],
                 help: string):
        if multiple_occurrences and default is not None:
            raise ArgparseError(
                "multiple occurrences options cannot have a default value")

        if choices is not None and default is not None:
            if default not in choices:
                raise ArgparseError(
                    f"default value {default} must be {join_or(choices)}")

        self.name = name
        self.short = short
        self.default = default
        self.takes_value = takes_value
        self.value_type = value_type

        if default is not None:
            self.takes_value = True

        self.multiple_occurrences = multiple_occurrences
        self.choices = choices
        self.help = help

    def is_flag(self) -> bool:
        return self.is_single_flag() or self.is_multiple_flag()

    def is_single_flag(self) -> bool:
        return not self.takes_value and not self.multiple_occurrences

    def is_multiple_flag(self) -> bool:
        return not self.takes_value and self.multiple_occurrences

    def is_single_value(self) -> bool:
        return self.takes_value and not self.multiple_occurrences

    def is_multiple_value(self) -> bool:
        return self.takes_value and self.multiple_occurrences

class _Positional:
    name: string
    value_type: ValueType
    multiple_occurrences: bool
    choices: [string]
    help: string

    def is_single_value(self) -> bool:
        return not self.multiple_occurrences

class _Reader:
    _argv: [string]
    _pos: u64

    def __init__(self, argv: [string], pos: u64):
        self._argv = argv
        self._pos = pos

    def available(self) -> bool:
        return self._pos < len(self._argv)

    def get(self) -> string:
        arg = self._argv[self._pos]
        self._pos += 1

        return arg

    def unget(self):
        self._pos -= 1

    def insert(self, arguments: [string]):
        argv = self._argv
        self._argv = arguments

        for arg in slice(argv, i64(self._pos)):
            self._argv.append(arg)

        self._pos = 0

class Args:
    """Returned by the parser's parse method.

    """

    _options: {string: i64}
    _single_values: {string: string}
    _multiple_values: {string: [string]}
    _subcommand: (string, Args)
    remaining: [string]

    def __init__(self,
                 options: {string: i64},
                 single_values: {string: string},
                 multiple_values: {string: [string]},
                 subcommand: (string, Args)):
        self._options = options
        self._single_values = single_values
        self._multiple_values = multiple_values
        self._subcommand = subcommand
        self.remaining = []

    def is_present(self, arg: string) -> bool:
        """Returns true if given presence (boolean) option was given, false
        otherwise.

        """

        return self.occurrences_of(arg) > 0

    def occurrences_of(self, arg: string) -> u64:
        """Returns the number of times given presence (boolean) option was
        given.

        """

        count = self._options.get(arg, -1)

        if count == -1:
            raise ArgparseError(f"{arg} does not exist")

        return u64(count)

    def value_of(self, arg: string) -> string:
        """Returns the value of given option or positional. Raises an error
        if given option does not take a value or if given positional can be
        given multiple times.

        """

        return self._single_values[arg]

    def values_of(self, arg: string) -> [string]:
        """Returns a list of values of given multiple occurrences option or
        positional.

        """

        return self._multiple_values[arg]

    def subcommand(self) -> (string, Args):
        """Returns a tuple of the subcommand and its arguments.

        """

        return self._subcommand

@enum
class ValueType:
    """Value type for completion scripts.

    """

    Path
    Hostname
    Other

class Parser:
    """An argument parser.

    """

    name: string
    help: string
    version: string
    _parent: Parser  # ToDo: weak[Parser]
    _options: [_Option]
    _positionals: [_Positional]
    _subcommands: [Parser]
    _options_count: {string: i64}
    _single_values: {string: string}
    _multiple_values: {string: [string]}
    _subcommand: (string, Args)
    _positional_index: u64

    def __init__(self,
                 name: string = None,
                 help: string = None,
                 version: string = None,
                 parent: Parser = None):
        self.name = name
        self.help = help
        self.version = version
        self._parent = parent
        self._options = []
        self._positionals = []
        self._subcommands = []
        self._add_builtin_options()

    def add_option(self,
                   name: string,
                   short: string = None,
                   takes_value: bool = False,
                   value_type: ValueType = ValueType.Other,
                   default: string = None,
                   multiple_occurrences: bool = False,
                   choices: [string] = None,
                   help: string = None):
        """Add an option. Options must be added before subcommands and
        positionals.

        """

        if self._subcommands != [] or self._positionals != []:
            raise ArgparseError(
                "options must be added before subcommands and positionals")

        if not name.starts_with("--"):
            raise ArgparseError("long options must start with '--'")

        if short is not None:
            if len(short) != 2 or short[0] != '-' or short[1] == '-':
                raise ArgparseError(
                    "short options must be a '-' followed by any character "
                    "except '-'")

        self._options.append(_Option(name,
                                     short,
                                     takes_value,
                                     value_type,
                                     default,
                                     multiple_occurrences,
                                     choices,
                                     help))

    def add_positional(self,
                       name: string,
                       value_type: ValueType = ValueType.Other,
                       multiple_occurrences: bool = False,
                       choices: [string] = None,
                       help: string = None):
        """Add a positional. Positionals cannot be mixed with subcommands.

        """

        if name.starts_with("-"):
            raise ArgparseError("positionals must not start with '-'")

        if self._subcommands != []:
            raise ArgparseError("positionals and subcommands cannot be mixed")

        if self._positionals != []:
            if self._positionals[-1].multiple_occurrences:
                raise ArgparseError(
                    "only the last posistional can occur multiple times")

        self._positionals.append(_Positional(name,
                                             value_type,
                                             multiple_occurrences,
                                             choices,
                                             help))

    def add_subcommand(self,
                       name: string,
                       help: string = None) -> Parser:
        """Add a subcommand. Subcommands cannot be mixed with positionals.

        """

        if name.starts_with("-"):
            raise ArgparseError("subcommands must not start with '-'")

        if self._positionals != []:
            raise ArgparseError("positionals and subcommands cannot be mixed")

        parser = Parser(name, help=help, parent=self)
        self._subcommands.append(parser)

        return parser

    def parse(self,
              argv: [string],
              exit_on_error: bool = True,
              allow_remaining: bool = False) -> Args:
        """Parse given arguments and return them.

        Give exit_on_error as False to raise an exception instead of
        exiting if an error occurs.

        Give allow_remaining to allow more non-option arguments than
        the parser expects. Remaining arguments are part of the
        returned value.

        """

        if self.name is None and len(argv) > 0:
            self.name = argv[0]

        reader = _Reader(argv, pos=1)

        try:
            args = self.parse_inner(reader)

            if reader.available():
                remaining: [string] = []

                while reader.available():
                    remaining.append(reader.get())

                if allow_remaining:
                    args.remaining = remaining
                else:
                    arguments = " ".join(remaining)

                    raise ArgparseError(
                        f"too many arguments, remaining: '{arguments}'")

            return args
        except ArgparseError as error:
            if exit_on_error:
                prefix = _style_error("error")

                raise SystemExitError(f"{prefix}: {error.message}")
            else:
                raise

    def print_help(self):
        prefix = self.format_synopsis_prefix()
        suffixes: [string] = []

        if self._options != []:
            suffixes.append(_style_option("[options]"))

        if self._subcommands != []:
            suffixes.append(_style_subcommand("<subcommand>"))

        for positional in self._positionals:
            suffixes.append(_style_positional(f"<{positional.name}>"))

        suffix = " ".join(suffixes)

        if suffix != "":
            suffix = " " + suffix

        name = _bold(prefix + self.name)
        synopsis = _underline("Synopsis")

        print(synopsis)
        print(f"  {name}{suffix}")

        if self.help is not None:
            print()
            print(_underline("Description"))
            print(indent(self.help, "  "))

        self._print_subcommands_help()
        self._print_positionals_help()
        self._print_options_help()

    def format_synopsis_prefix(self) -> string:
        if self._parent is not None:
            prefix = self._parent.format_synopsis_prefix()

            return f"{prefix}{self._parent.name} "
        else:
            return ""

    def _print_subcommands_help(self):
        if self._subcommands == []:
            return

        print()
        print(_underline("Subcommands"))
        entries: [(string, i64, string)] = []
        longest_name: i64 = 0

        for subcommand in self._subcommands:
            help = ""

            if subcommand.help is not None:
                help = subcommand.help

            name = subcommand.name
            name_length = i64(len(name))
            longest_name = max(name_length, longest_name)
            entries.append((name, name_length, help))

        for name, name_length, help in entries:
            name = _pad(name, longest_name - name_length)
            print(f"  {_style_subcommand(name)}    {help}")

    def _print_options_help(self):
        if self._options == []:
            return

        print()
        print(_underline("Options"))
        entries: [(string, i64, string)] = []
        longest_options: i64 = 0
        longest_options = self.get_options_help([], entries, longest_options)

        for options, options_length, help in entries:
            options = _pad(options, longest_options - options_length)
            print(f"  {_style_option(options)}    {help}")

    def _options_names(self) -> [string]:
        return [option.name for option in self._options]

    def get_options_help(self,
                         options_to_skip: [string],
                         entries: [(string, i64, string)],
                         longest_options: i64) -> i64:
        if self._options == []:
            return longest_options

        for option in self._options:
            if option.name in options_to_skip:
                continue

            help = ""

            if option.help is not None:
                help = option.help

            if option.short is not None:
                short = f"{option.short}, "
            else:
                short = ""

            options = short + option.name
            options_length = i64(len(options))
            longest_options = max(options_length, longest_options)
            entries.append((options, options_length, help))

        if self._parent is not None:
            longest_options = self._parent.get_options_help(
                options_to_skip + self._options_names(),
                entries,
                longest_options)

        return longest_options

    def _print_positionals_help(self):
        if self._positionals == []:
            return

        print()
        print(_underline("Positionals"))
        entries: [(string, i64, string)] = []
        longest_name: i64 = 0

        for positional in self._positionals:
            help = ""

            if positional.help is not None:
                help = positional.help

            name = positional.name
            name_length = i64(len(name))
            longest_name = max(name_length, longest_name)
            entries.append((name, name_length, help))

        for name, name_length, help in entries:
            name = _pad(name, longest_name - name_length)
            print(f"  {_style_positional(name)}    {help}")

    def _find_option(self, name: string) -> _Option:
        for option in self._options:
            if option.name == name or option.short == name:
                return option

        return None

    def _add_builtin_options(self):
        self.add_option("--help",
                        short="-h",
                        help="Show this help.")

        if self.version is not None:
            self.add_option("--version",
                            help="Show version infomation.")

        self.add_option("--shell-completion",
                        takes_value=True,
                        choices=["zsh"],
                        help="Print the shell command completion script.")

    def _handle_builtin_options(self, option: _Option, reader: _Reader):
        match option.name:
            case "--help":
                self.print_help()

                raise SystemExitError()
            case "--version":
                if self.version is not None:
                    print(self.version)

                    raise SystemExitError()
            case "--shell-completion":
                match self._read_option_value(option, reader):
                    case "zsh":
                        print(self.zsh_completion(), end="")

                        raise SystemExitError()

    def parse_option(self, reader: _Reader, options_to_skip: [string]):
        name = reader.get()
        option = self._find_option(name)

        if option is None:
            if self._parent is None:
                raise ArgparseError(f"invalid option {_style_error(name)}")

            reader.unget()
            self._parent.parse_option(reader,
                                      options_to_skip + self._options_names())

            return

        if option.name in options_to_skip:
            raise ArgparseError(f"invalid option {_style_error(name)}")

        self._handle_builtin_options(option, reader)
        name = option.name

        if option.is_single_flag():
            if self._options_count[name] > 0:
                raise ArgparseError(
                    f"{_style_option(name)} can only be given once")

            self._options_count[name] = 1
        elif option.is_multiple_flag():
            self._options_count[name] += 1
        else:
            value = self._read_option_value(option, reader)

            if option.is_single_value():
                if self._single_values[name] is not None:
                    raise ArgparseError(
                        f"{_style_option(name)} can only be given once")

                self._single_values[name] = value
            else:
                self._multiple_values[name].append(value)

    def _read_option_value(self, option: _Option, reader: _Reader) -> string:
        if not reader.available():
            raise ArgparseError(
                f"value missing for option {_style_option(option.name)}")

        value = reader.get()

        if option.choices is not None:
            if value not in option.choices:
                choices = [_style_option(choice) for choice in option.choices]

                raise ArgparseError(
                    f"invalid value {_style_error(value)} to option "
                    f"{_style_option(option.name)}, choose from "
                    f"{join_and(choices)}")

        return value

    def _find_subcommand(self, name: string) -> Parser:
        for subcommand in self._subcommands:
            if subcommand.name == name:
                return subcommand

        choices = join_and([_style_subcommand(subcommand.name)
                            for subcommand in self._subcommands])

        raise ArgparseError(
            f"invalid subcommand {_style_error(name)}, choose from {choices}")

    def _parse_subcommand(self, reader: _Reader) -> (string, Args):
        subcommand = self._find_subcommand(reader.get())

        return (subcommand.name, subcommand.parse_inner(reader))

    def _parse_positional(self, reader: _Reader) -> bool:
        if self._positional_index == len(self._positionals):
            return False

        positional = self._positionals[self._positional_index]
        self._positional_index += 1
        name = positional.name
        value = reader.get()

        if positional.choices is not None:
            if value not in positional.choices:
                choices = [_style_positional(choice)
                           for choice in positional.choices]

                raise ArgparseError(
                    f"invalid value {_style_error(value)} to positional "
                    f"{_style_positional(name)}, choose from "
                    f"{join_and(choices)}")

        if positional.is_single_value():
            self._single_values[name] = value
        else:
            self._multiple_values[name] = [value]

            while reader.available():
                self._multiple_values[name].append(reader.get())

        return True

    def parse_inner(self, reader: _Reader) -> Args:
        self._options_count = {}
        self._single_values = {}
        self._multiple_values = {}
        self._subcommand = None
        self._positional_index = 0
        end_of_options_found = False

        for option in self._options:
            if option.is_flag():
                self._options_count[option.name] = 0
            elif option.is_single_value():
                self._single_values[option.name] = None
            elif option.is_multiple_value():
                self._multiple_values[option.name] = []

        while reader.available():
            argument = reader.get()

            if argument == "--" and not end_of_options_found:
                end_of_options_found = True
            else:
                reader.unget()

                if (end_of_options_found
                    or argument == "-"
                    or not argument.starts_with("-")):
                    if self._subcommands != []:
                        self._subcommand = self._parse_subcommand(reader)
                        break
                    elif not self._parse_positional(reader):
                        break
                else:
                    if not argument.starts_with("--") and len(argument) > 2:
                        reader.get()
                        reader.insert([f"-{short}" for short in slice(argument, 1)])

                    self.parse_option(reader, [])

        for option in self._options:
            if option.is_single_value():
                if self._single_values[option.name] is None:
                    self._single_values[option.name] = option.default

        if self._subcommands != []:
            if self._subcommand is None:
                choices = join_and([_style_subcommand(subcommand.name)
                                    for subcommand in self._subcommands])

                raise ArgparseError(f"subcommand missing, choose from {choices}")
        elif self._positional_index < len(self._positionals):
            positional = self._positionals[self._positional_index]

            raise ArgparseError(
                f"positional {_style_positional(positional.name)} missing")

        return Args(self._options_count,
                    self._single_values,
                    self._multiple_values,
                    self._subcommand)

    def zsh_completion(self) -> string:
        """Returns the Zsh command completion script.

        """

        body, functions = self.zsh_completion_inner(self.name)

        if functions != "":
            functions += "\n\n"

        return (
            f"#compdef {self.name}\n"
            "\n"
            f"_{self.name}() {{\n"
            "    local state line\n"
            "\n"
            f"{indent(body)}\n"
            "}\n"
            "\n"
            f"{functions}"
            f"_{self.name} \"$@\"\n")

    def _zsh_completion_options(self, arguments: [string]):
        for option in self._options:
            if option.choices is not None:
                choices = " ".join(option.choices)
                value = f":value:({choices})"
            elif option.takes_value:
                value = _zsh_value_type_string(option.value_type)
                value = f":value:{value}"
            else:
                value = ""

            if option.help is not None:
                help = f"[{option.help}]"
            else:
                help = ""

            if option.short is not None:
                arguments.append(f"    '{option.short}{help}{value}'")

            arguments.append(f"    '{option.name}{help}{value}'")

    def _zsh_completion_positionals(self, arguments: [string]):
        for positional in self._positionals:
            if positional.choices is not None:
                choices = " ".join(positional.choices)
                value = f"({choices})"
            else:
                value = _zsh_value_type_string(positional.value_type)

            arguments.append(f"    ':{positional.name}:{value}'")

    def _zsh_completion_subcommands(self,
                                    prefix: string,
                                    arguments: [string]) -> (string, [string]):
        case_string: string = None
        functions: [string] = []

        if self._subcommands != []:
            function_name = f"_{prefix}_subcommand"
            arguments.append(f"    ':::{function_name}'")
            subcommands: [string] = []
            cases: [string] = []

            for subcommand in self._subcommands:
                if subcommand.help is not None:
                    help = subcommand.help
                else:
                    help = ""

                subcommands.append(f"        '{subcommand.name}:{help}'")
                case_body, case_functions = subcommand.zsh_completion_inner(
                    f"{prefix}_{subcommand.name}")
                case_body = indent(case_body, "    ")
                cases.append(indent(f"{subcommand.name})\n"
                                    f"{case_body}\n"
                                    "    ;;",
                                    "            "))

                if case_functions != "":
                    functions.append(case_functions)

            arguments.append("    '*::: :->node'")

            cases_string = "\n".join(cases)
            case_string = (
                "case $state in\n"
                "    node)\n"
                "        words=($line[1] \"${words[@]}\")\n"
                "        (( CURRENT += 1 ))\n"
                "\n"
                "        case $line[1] in\n"
                f"{cases_string}\n"
                "        esac\n"
                "        ;;\n"
                "esac")

            subcommands_string = " \\\n".join(subcommands)
            functions.append(f"{function_name}() {{\n"
                             "    local subcommands;\n"
                             "    subcommands=(\n"
                             f"{subcommands_string} \\\n"
                             "    )\n"
                             "    _describe 'command' subcommands\n"
                             "}")

        return case_string, functions

    def zsh_completion_inner(self, prefix: string) -> (string, string):
        arguments: [string] = []

        self._zsh_completion_options(arguments)
        self._zsh_completion_positionals(arguments)
        case_string, functions = self._zsh_completion_subcommands(prefix, arguments)

        body = ""

        if arguments != []:
            body += "_arguments -S \\\n"
            body += " \\\n".join(arguments)

        if case_string is not None:
            body += f"\n\n{case_string}"

        return body, "\n\n".join(functions)

@test
def test_cat_and_monkey_subcommands():
    parser = Parser("foo",
                    help="Does awesome things",
                    version="1.0.0")
    parser.add_option("--verbose",
                      short="-v",
                      multiple_occurrences=True,
                      help="Verbose output.")

    monkey = parser.add_subcommand("monkey", help="Some more stuff.")
    monkey.add_option("--height", default="80")
    monkey.add_positional("banana", multiple_occurrences=True, help="Banana?")

    cat = parser.add_subcommand("cat", help="What?")
    cat.add_option("--auto", short="-a")
    cat.add_option("--rate", default="10000")
    cat.add_positional("food")

    try:
        parser.parse(["foo"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"subcommand missing, choose from {CYAN}monkey{RESET} "
            f"and {CYAN}cat{RESET}")

    args = parser.parse(["foo", "--verbose", "cat", ""])
    assert args.occurrences_of("--verbose") == 1

    args = parser.parse(["foo", "-vvv", "cat", "rat"])
    assert args.occurrences_of("--verbose") == 3

    args = parser.parse(["foo", "cat", "--auto", "rat"])
    assert not args.is_present("--verbose")
    name, args = args.subcommand()
    assert name == "cat"
    assert args.is_present("--auto")
    assert args.value_of("--rate") == "10000"
    assert args.value_of("food") == "rat"

    args = parser.parse(["foo", "monkey", "--height", "75", "b1", "b2"])
    assert not args.is_present("--verbose")
    name, args = args.subcommand()
    assert name == "monkey"
    assert args.value_of("--height") == "75"
    assert args.values_of("banana") == ["b1", "b2"]

@test
def test_add_option_after_positional():
    parser = Parser("bar")
    parser.add_positional("out")

    try:
        parser.add_option("--verbose")
        assert False
    except ArgparseError as error:
        assert error.message == (
            "options must be added before subcommands and positionals")

@test
def test_add_multiple_occurrences_positional_before_positional():
    parser = Parser("bar")
    parser.add_positional("out", multiple_occurrences=True)

    try:
        parser.add_option("in")
        assert False
    except ArgparseError as error:
        assert error.message == (
            "options must be added before subcommands and positionals")

@test
def test_help():
    parser = Parser("foo",
                    help="Does awesome things",
                    version="1.0.0")
    parser.add_option("--verbose",
                      short="-v",
                      multiple_occurrences=True,
                      help="Verbose output.")

    monkey = parser.add_subcommand("monkey", help="Some more stuff.")
    monkey.add_option("--height", default="80")
    monkey.add_positional("banana", multiple_occurrences=True, help="Banana?")

    cat = parser.add_subcommand("cat", help="What?")
    cat.add_option("--auto", short="-a")
    cat.add_option("--rate", default="10000")
    cat.add_positional("food")

    try:
        parser.parse(["foo", "--help"])
        assert False
    except SystemExitError:
        pass

    try:
        parser.parse(["foo", "cat", "--help"])
        assert False
    except SystemExitError:
        pass

@test
def test_version():
    parser = Parser("foo", version="0.3.0")

    try:
        parser.parse(["foo", "--version"])
        assert False
    except SystemExitError:
        pass

@test
def test_no_version():
    parser = Parser("foo")

    try:
        parser.parse(["foo", "--version"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"invalid option {RED}{BOLD}--version{RESET}"

@test
def test_is_present():
    parser = Parser("bar")
    parser.add_option("--foo")

    args = parser.parse(["bar", "--foo"])
    assert args.is_present("--foo")

    args = parser.parse(["bar"])
    assert not args.is_present("--foo")

@test
def test_is_present_bad_option():
    parser = Parser("bar")

    args = parser.parse(["bar"])

    try:
        args.is_present("--foo")
        assert False
    except ArgparseError as error:
        assert error.message == "--foo does not exist"

@test
def test_add_subcommand_after_positional():
    parser = Parser("bar")
    parser.add_positional("foo")

    try:
        parser.add_subcommand("cat")
        assert False
    except ArgparseError as error:
        assert error.message == "positionals and subcommands cannot be mixed"

@test
def test_add_positional_after_subcommand():
    parser = Parser("bar")
    parser.add_subcommand("cat")

    try:
        parser.add_positional("foo")
        assert False
    except ArgparseError as error:
        assert error.message == "positionals and subcommands cannot be mixed"

@test
def test_add_invalid_option():
    parser = Parser("bar")

    try:
        parser.add_option("cat")
        assert False
    except ArgparseError as error:
        assert error.message == "long options must start with '--'"

@test
def test_add_invalid_short_option_1():
    parser = Parser("bar")

    try:
        parser.add_option("--cat", short="d")
        assert False
    except ArgparseError as error:
        assert error.message == (
            "short options must be a '-' followed by any character except '-'")

@test
def test_add_invalid_short_option_2():
    parser = Parser("bar")

    try:
        parser.add_option("--cat", short="--g")
        assert False
    except ArgparseError as error:
        assert error.message == (
            "short options must be a '-' followed by any character except '-'")

@test
def test_add_invalid_short_option_3():
    parser = Parser("bar")

    try:
        parser.add_option("--cat", short="--")
        assert False
    except ArgparseError as error:
        assert error.message == (
            "short options must be a '-' followed by any character except '-'")

@test
def test_invalid_suncommand():
    parser = Parser("bar")
    parser.add_subcommand("cat")

    try:
        parser.parse(["bar", "foo"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"invalid subcommand {RED}{BOLD}foo{RESET}, choose "
            f"from {CYAN}cat{RESET}")

@test
def test_single_option_given_multiple_times():
    parser = Parser("bar")
    parser.add_option("--cat")

    try:
        parser.parse(["bar", "--cat", "--cat"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"{YELLOW}--cat{RESET} can only be given once"

@test
def test_all_arguments_not_used():
    parser = Parser("bar")
    parser.add_positional("cat")

    try:
        parser.parse(["bar", "apa", "ko"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == "too many arguments, remaining: 'ko'"

@test
def test_allow_remaining():
    parser = Parser("bar")

    args = parser.parse(["bar", "apa"], allow_remaining=True)

    assert args.remaining == ["apa"]

@test
def test_allow_remaining_option_after_dash_dash():
    parser = Parser("bar")
    parser.add_option("--cat")

    args = parser.parse(["bar", "--", "--cat", "apa"], allow_remaining=True)

    assert not args.is_present("--cat")
    assert args.remaining == ["--cat", "apa"]

@test
def test_allow_remaining_with_subparser():
    parser = Parser("bar")
    cat = parser.add_subcommand("cat")
    cat.add_option("--foo")

    args = parser.parse(["bar", "cat", "--", "apa", "--foo"], allow_remaining=True)

    assert args.remaining == ["apa", "--foo"]

    name, args = args.subcommand()
    assert name == "cat"
    assert args.remaining == []

@test
def test_multiple_occurrences_option_that_takes_value():
    parser = Parser("bar")
    parser.add_option("--cat",
                      takes_value=True,
                      multiple_occurrences=True)
    args = parser.parse(["bar", "--cat", "1", "--cat", "2"])
    assert args.values_of("--cat") == ["1", "2"]

@test
def test_multiple_occurrences_option_that_takes_value_missing_value():
    parser = Parser("bar")
    parser.add_option("--cat",
                      takes_value=True,
                      multiple_occurrences=True)

    try:
        parser.parse(["bar", "--cat", "1", "--cat"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"value missing for option {YELLOW}--cat{RESET}"

@test
def test_option_missing_value():
    parser = Parser()
    parser.add_option("--aaa", short="-a", takes_value=True)
    parser.add_option("--bbb", short="-b")

    try:
        parser.parse(["a", "-ba"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"value missing for option {YELLOW}--aaa{RESET}"

@test
def test_single_occurrence_option_that_takes_value_given_twice():
    parser = Parser("bar")
    parser.add_option("--cat", takes_value=True)

    try:
        parser.parse(["bar", "--cat", "1", "--cat", "2"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"{YELLOW}--cat{RESET} can only be given once"

@test
def test_missing_positional():
    parser = Parser("bar")
    parser.add_positional("cat")

    try:
        parser.parse(["bar"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"positional {CYAN}cat{RESET} missing"

@test
def test_no_name():
    parser = Parser()
    parser.parse(["bar"])
    assert parser.name == "bar"

@test
def test_exit_on_error():
    parser = Parser()

    try:
        parser.parse(["foo", "--version"])
        assert False
    except SystemExitError as error:
        assert str(error) == (
            "SystemExitError(message="
            f"\"{RED}{BOLD}error{RESET}: invalid option "
            f"{RED}{BOLD}--version{RESET}\")")

@test
def test_bad_option_single_dash():
    parser = Parser()

    try:
        parser.parse(["foo", "-"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == "too many arguments, remaining: '-'"

@test
def test_option_choices():
    parser = Parser("bar")
    parser.add_option("--cat",
                      takes_value=True,
                      choices=["a", "b"])

    args = parser.parse(["bar", "--cat", "a"])
    assert args.value_of("--cat") == "a"

    args = parser.parse(["bar", "--cat", "b"])
    assert args.value_of("--cat") == "b"

    try:
        parser.parse(["bar", "--cat", "c"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"invalid value {RED}{BOLD}c{RESET} to option "
            f"{YELLOW}--cat{RESET}, choose from {YELLOW}a{RESET} and "
            f"{YELLOW}b{RESET}")

@test
def test_positional_choices():
    parser = Parser("bar")
    parser.add_positional("cat", choices=["a", "b"])

    args = parser.parse(["bar", "a"])
    assert args.value_of("cat") == "a"

    args = parser.parse(["bar", "b"])
    assert args.value_of("cat") == "b"

    try:
        parser.parse(["bar", "c"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"invalid value {RED}{BOLD}c{RESET} to positional "
            f"{CYAN}cat{RESET}, choose from {CYAN}a{RESET} and "
            f"{CYAN}b{RESET}")

@test
def test_end_of_options():
    parser = Parser()
    parser.add_option("--cat")
    foo = parser.add_subcommand("foo")
    foo.add_option("--cat")
    foo.add_positional("in")
    foo.add_positional("out")

    try:
        parser.parse(["bar", "--", "--cat"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"invalid subcommand {RED}{BOLD}--cat{RESET}, choose "
            f"from {CYAN}foo{RESET}")

    args = parser.parse(["bar", "--", "foo", "-", "-"])
    _, args = args.subcommand()
    assert args.value_of("in") == "-"
    assert args.value_of("out") == "-"

    args = parser.parse(["bar", "--", "foo", "--", "-", "-"])
    _, args = args.subcommand()
    assert args.value_of("out") == "-"

    args = parser.parse(["bar", "foo", "a", "--", "--cat"])
    _, args = args.subcommand()
    assert args.value_of("in") == "a"
    assert args.value_of("out") == "--cat"
    assert not args.is_present("--cat")

    try:
        parser.parse(["bar", "foo", "a", "--cat"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"positional {CYAN}out{RESET} missing"

    args = parser.parse(["bar", "foo", "a", "--cat", "b"])
    _, args = args.subcommand()
    assert args.value_of("in") == "a"
    assert args.value_of("out") == "b"
    assert args.is_present("--cat")

    try:
        parser.parse(["bar", "foo", "a", "--", "--cat", "b", "c", "d"],
                     exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == "too many arguments, remaining: 'b c d'"

    args = parser.parse(["bar", "foo", "a", "--", "--"])
    _, args = args.subcommand()
    assert args.value_of("in") == "a"
    assert args.value_of("out") == "--"
    assert not args.is_present("--cat")

@test
def test_positional_name_must_not_start_with_dash():
    parser = Parser()

    try:
        parser.add_positional("--out")
        assert False
    except ArgparseError as error:
        assert error.message == "positionals must not start with '-'"

@test
def test_subcommand_name_must_not_start_with_dash():
    parser = Parser()

    try:
        parser.add_subcommand("--out")
        assert False
    except ArgparseError as error:
        assert error.message == "subcommands must not start with '-'"

@test
def test_parent_options_in_subcommand():
    parser = Parser()
    parser.add_option("--cat", multiple_occurrences=True)
    foo = parser.add_subcommand("foo")

    args = parser.parse(["bar", "--cat", "foo"])
    assert args.is_present("--cat")

    args = parser.parse(["bar", "foo", "--cat"])
    assert args.is_present("--cat")

    args = parser.parse(["bar", "--cat", "foo", "--cat"])
    assert args.occurrences_of("--cat") == 2

@test
def test_skip_parent_option_with_same_name_as_in_subcommand():
    parser = Parser()
    parser.add_option("--foo", short="-f")
    bar = parser.add_subcommand("bar")
    bar.add_option("--foo")

    try:
        parser.parse(["bar", "bar", "--help"])
    except SystemExitError:
        pass

    args = parser.parse(["bar", "bar", "--foo"])
    assert not args.is_present("--foo")
    _, args = args.subcommand()
    assert args.is_present("--foo")

    # bar subcommand option --foo is prioritized, -f cannot be used.
    try:
        parser.parse(["bar", "bar", "-f"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == f"invalid option {RED}{BOLD}-f{RESET}"

@test
def test_zsh_completion_empty_parser():
    assert Parser("foobar").zsh_completion() == (
        "#compdef foobar\n"
        "\n"
        "_foobar() {\n"
        "    local state line\n"
        "\n"
        "    _arguments -S \\\n"
        "        '-h[Show this help.]' \\\n"
        "        '--help[Show this help.]' \\\n"
        "        '--shell-completion[Print the shell command completion script.]"
        ":value:(zsh)'\n"
        "}\n"
        "\n"
        "_foobar \"$@\"\n")

@test
def test_zsh_completion_version_parser():
    assert Parser("foobar", version="1.0.0").zsh_completion() == (
        "#compdef foobar\n"
        "\n"
        "_foobar() {\n"
        "    local state line\n"
        "\n"
        "    _arguments -S \\\n"
        "        '-h[Show this help.]' \\\n"
        "        '--help[Show this help.]' \\\n"
        "        '--version[Show version infomation.]' \\\n"
        "        '--shell-completion[Print the shell command completion script.]"
        ":value:(zsh)'\n"
        "}\n"
        "\n"
        "_foobar \"$@\"\n")

@test
def test_zsh_completion_options_and_positionals():
    parser = Parser("foo")
    parser.add_option("--sound",
                      short="-s",
                      takes_value=True,
                      help="Sound.")
    parser.add_option("--sound2",
                      takes_value=True,
                      value_type=ValueType.Path)
    parser.add_option("--address",
                      takes_value=True,
                      value_type=ValueType.Hostname)
    parser.add_positional("bar")
    parser.add_positional("bar2", value_type=ValueType.Path)
    parser.add_positional("ko", choices=["a", "bb"])

    assert parser.zsh_completion() == (
        "#compdef foo\n"
        "\n"
        "_foo() {\n"
        "    local state line\n"
        "\n"
        "    _arguments -S \\\n"
        "        '-h[Show this help.]' \\\n"
        "        '--help[Show this help.]' \\\n"
        "        '--shell-completion[Print the shell command completion script.]"
        ":value:(zsh)' \\\n"
        "        '-s[Sound.]:value:( )' \\\n"
        "        '--sound[Sound.]:value:( )' \\\n"
        "        '--sound2:value:_files' \\\n"
        "        '--address:value:_hosts' \\\n"
        "        ':bar:( )' \\\n"
        "        ':bar2:_files' \\\n"
        "        ':ko:(a bb)'\n"
        "}\n"
        "\n"
        "_foo \"$@\"\n")

@test
def test_zsh_completion_subcommands():
    parser = Parser("kalle")

    foo = parser.add_subcommand("foo")
    foo.add_subcommand("fum")

    bar = parser.add_subcommand("bar")
    bar.add_subcommand("fie", help="Hi fie!")

    assert parser.zsh_completion() == (
        "#compdef kalle\n"
        "\n"
        "_kalle() {\n"
        "    local state line\n"
        "\n"
        "    _arguments -S \\\n"
        "        '-h[Show this help.]' \\\n"
        "        '--help[Show this help.]' \\\n"
        "        '--shell-completion[Print the shell command completion script.]"
        ":value:(zsh)' \\\n"
        "        ':::_kalle_subcommand' \\\n"
        "        '*::: :->node'\n"
        "\n"
        "    case $state in\n"
        "        node)\n"
        "            words=($line[1] \"${words[@]}\")\n"
        "            (( CURRENT += 1 ))\n"
        "\n"
        "            case $line[1] in\n"
        "                foo)\n"
        "                    _arguments -S \\\n"
        "                        '-h[Show this help.]' \\\n"
        "                        '--help[Show this help.]' \\\n"
        "                        '--shell-completion[Print the shell command completion "
        "script.]:value:(zsh)' \\\n"
        "                        ':::_kalle_foo_subcommand' \\\n"
        "                        '*::: :->node'\n"
        "\n"
        "                    case $state in\n"
        "                        node)\n"
        "                            words=($line[1] \"${words[@]}\")\n"
        "                            (( CURRENT += 1 ))\n"
        "\n"
        "                            case $line[1] in\n"
        "                                fum)\n"
        "                                    _arguments -S \\\n"
        "                                        '-h[Show this help.]' \\\n"
        "                                        '--help[Show this help.]' \\\n"
        "                                        '--shell-completion[Print the shell "
        "command completion script.]:value:(zsh)'\n"
        "                                    ;;\n"
        "                            esac\n"
        "                            ;;\n"
        "                    esac\n"
        "                    ;;\n"
        "                bar)\n"
        "                    _arguments -S \\\n"
        "                        '-h[Show this help.]' \\\n"
        "                        '--help[Show this help.]' \\\n"
        "                        '--shell-completion[Print the shell command completion "
        "script.]:value:(zsh)' \\\n"
        "                        ':::_kalle_bar_subcommand' \\\n"
        "                        '*::: :->node'\n"
        "\n"
        "                    case $state in\n"
        "                        node)\n"
        "                            words=($line[1] \"${words[@]}\")\n"
        "                            (( CURRENT += 1 ))\n"
        "\n"
        "                            case $line[1] in\n"
        "                                fie)\n"
        "                                    _arguments -S \\\n"
        "                                        '-h[Show this help.]' \\\n"
        "                                        '--help[Show this help.]' \\\n"
        "                                        '--shell-completion[Print the shell "
        "command completion script.]:value:(zsh)'\n"
        "                                    ;;\n"
        "                            esac\n"
        "                            ;;\n"
        "                    esac\n"
        "                    ;;\n"
        "            esac\n"
        "            ;;\n"
        "    esac\n"
        "}\n"
        "\n"
        "_kalle_foo_subcommand() {\n"
        "    local subcommands;\n"
        "    subcommands=(\n"
        "        'fum:' \\\n"
        "    )\n"
        "    _describe 'command' subcommands\n"
        "}\n"
        "\n"
        "_kalle_bar_subcommand() {\n"
        "    local subcommands;\n"
        "    subcommands=(\n"
        "        'fie:Hi fie!' \\\n"
        "    )\n"
        "    _describe 'command' subcommands\n"
        "}\n"
        "\n"
        "_kalle_subcommand() {\n"
        "    local subcommands;\n"
        "    subcommands=(\n"
        "        'foo:' \\\n"
        "        'bar:' \\\n"
        "    )\n"
        "    _describe 'command' subcommands\n"
        "}\n"
        "\n"
        "_kalle \"$@\"\n")

@test
def test_shell_completion_zsh():
    parser = Parser("foo")

    try:
        parser.parse(["foo", "--shell-completion", "zsh"])
        assert False
    except SystemExitError:
        pass

@test
def test_shell_completion_bad_value():
    parser = Parser("foo")

    try:
        parser.parse(["foo", "--shell-completion", "bad"], exit_on_error=False)
        assert False
    except ArgparseError as error:
        assert error.message == (
            f"invalid value {RED}{BOLD}bad{RESET} to option "
            f"{YELLOW}--shell-completion{RESET}, choose from {YELLOW}zsh{RESET}")
